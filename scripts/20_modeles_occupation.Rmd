---
title: "20_modeles_occupation"
author: "Léa Bouchet"
date: "2024-04-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Modèles d'occupation

La première étape est de transformer le jeu de données en détection / non détection (présence / absence d'un espèce : TRUE / FALSE) sur un site donné. Le premier modèle tester est un modèle d'occupation d'une seule espèce (donc à l'espèce).



# Installation 

## Chargement des packages, fonctions et des données 

```{r Chargement des packages, données et fonctions}

## Chargement des packages ----
library(ggthemes)
library(tidyverse)
library(aspe)
library(ggplot2)
library (khroma)
library(dplyr)
library(wesanderson)
library(zoo)
library(lemon)
library(trend)
library(ggh4x)
library(spOccupancy)
library(coda)
library(stars)


## Chargement des données ----
load(file = "../processed_data/selection_pop_ope.rda")
load(file = "../processed_data/pre_traitements_donnees_env.rda")
load(file = "../processed_data/assemblage_tab_par_ope.rda")
load(file = "../processed_data/analyse_selection_especes.rda")



# Définition des couleurs de l'OFB en format RGB
pal <- c("#007844", "#92D050", "#0087C1", "#FCEE21", "#00AEEF", "#1D1D1B", "#A97B30", "#B9D9EB")
```

# Constitution du jeu de données

On souhaite transformer notre jeu de données en ABSENCE / PRESENCE : où absence = 0 et présence = 1 : 

```{r}
mon_espece <- "ANG"

point_prelevement_t <- point_prelevement %>% 
  select(pop_id,
         pop_coordonnees_x,
         pop_coordonnees_y) %>% 
  rename (V1 = pop_coordonnees_x,
          V2 = pop_coordonnees_y)

mes_combinaisons <- expand.grid(ope_ind$ope_id, ope_ind$esp_code_alternatif) %>% 
  distinct() %>% 
  rename(ope_id = Var1,
         esp_code_alternatif = Var2)

ope_ind <- ope_indicateur %>% 
  filter(indicateur == "densite_surface") %>% 
  select (ope_id,
          esp_code_alternatif
           ) %>% 
  unique() %>% 
  mutate (presence = 1)

y <- mes_combinaisons %>% 
  left_join(y = ope_ind) %>% 
  mutate(presence = ifelse(is.na(presence), 0, presence)) %>% 
  left_join(y = ope_selection %>% 
              select(ope_id,
                     pop_id,
                     annee
                    # ope_date
                     )) %>% 
              select(-ope_id) %>% 
              distinct() %>% 
#  mutate(annee = paste0("a_", annee)) %>% 
  filter(esp_code_alternatif == mon_espece) %>% 
  select(-esp_code_alternatif) %>% 
  arrange(annee) %>% 
  pivot_wider(names_from = annee,
              values_from = presence) %>% 
  arrange(pop_id)


occ.covs <- ope_selection_param_env %>% 
  group_by(pop_id, parametre) %>% 
  summarise(valeur = median(valeur, na.rm = TRUE)) %>% 
  ungroup() %>% 
  mutate(valeur = log10(valeur)) %>% 
  pivot_wider(names_from = parametre,
              values_from = valeur) %>% 
  arrange(pop_id)
  

test <- ope_selection %>% 
  mutate(jour = lubridate::yday(ope_date)) %>% 
  mutate(protocole = as.factor(pro_libelle),
         protocole = as.integer(protocole)) %>% 
  select(pop_id,
         annee,
         jour,
         protocole)

jour <- test %>% 
  select(-protocole) %>% 
  arrange(annee) %>% 
  pivot_wider(names_from = annee,
              values_from = jour) %>% 
  arrange(pop_id)

protocole <- test %>% 
  select(-jour) %>% 
  arrange(annee) %>% 
  pivot_wider(names_from = annee,
              values_from = protocole) %>% 
  arrange(pop_id)

modele_ang <- list()

modele_ang$y <- y
modele_ang$occ.covs <- occ.covs
modele_ang$det.covs$jour <- jour
modele_ang$det.covs$protocole <- protocole
```


```{r}
ang.occ.formula <- ~ scale(profondeur) + scale(pente) + scale(temp_juillet)
ang.det.formula <- ~ scale(jour) + scale(protocole) + I(scale(jour)^2)
```

```{r}
ang.inits <- list(alpha = 0, 
                   beta = 0, 
                   z = apply(modele_ang$y, 1, max, na.rm = TRUE))
```

```{r}
ang.priors <- list(alpha.normal = list(mean = 0, var = 2.72), 
                    beta.normal = list(mean = 0, var = 2.72))
```

```{r}
n.samples <- 5000
n.burn <- 3000
n.thin <- 2
n.chains <- 3
```

```{r}
out <- PGOcc(occ.formula = ang.occ.formula, 
             det.formula = ang.det.formula, 
             data = modele_ang, 
             inits = ang.inits, 
             n.samples = n.samples, 
             priors = ang.priors, 
             n.omp.threads = 1, 
             verbose = TRUE, 
             n.report = 1000, 
             n.burn = n.burn, 
             n.thin = n.thin, 
             n.chains = n.chains)
```



```{r}
# Chargement des packages nécessaires
library(spOccupancy)

# Chargement de ton jeu de données transformé (lop_long)
# Assure-toi d'avoir préalablement transformé tes données comme indiqué précédemment

# Exemple de nom de colonnes : annee pour l'année, species pour le nom de l'espèce, presence_absence pour la présence/absence

# Spécification des formules du modèle
occ.formula <- ~ 1  # Occurrence en fonction d'une constante (intercept)
det.formula <- ~ 1   # Détection en fonction d'une constante (intercept)

# Lancement du modèle
out <- spPGOcc(occ.formula = occ.formula,
               det.formula = det.formula,
               data = lop_esp_ANG,  # Utilisation de ton jeu de données transformé
               n.batch = 400,
               batch.length = 25,
               accept.rate = 0.43,
               cov.model = "exponential",
               NNGP = TRUE,
               n.neighbors = 5,
               n.burn = 2000,
               n.thin = 4,
               n.chains = 3,
               verbose = FALSE,
               k.fold = 2)

# Affichage du résumé du modèle
summary(out)

```



