---
title: "Liste Rouge Régionale des poissons d'eau douce de Bretagne"
subtitle: "Prétraitement des données opération et des données individuelles des espèces"
author: "OFB Bretagne"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
params:
  passage_a_retirer: !r c("2","3") # Sélection du nombre de passage souhaité ; Remarque : si je souhaite enlever les 1ers passages, sélection "0","1"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
```

# Objectif : Dynamique de population des poissons d'eau douce de Bretagne - 
04_pre_traitements_donnees_ope_especes


Il s'agit ici de réaliser une étape de pré-traitement / mise en qualité sur la sélection des opérations et sur les données des espèces propre à chacune des opérations. Il s'agit notamment d'observer les valeurs aberrantes contenues dans les mesures individuelles des différentes espèces de poissons d'eau douce. Il s'agit donc d'une mise en qualité des données (tailles / poids) par individu de poissons pêchés. 



# Installation 

## Paramètres 

Plusieurs paramètres sont fixés au début du scripts : ces paramètres sont modifiables selon les préférences et les objectifs visés. Parmi ces paramètres :

- Sélection des passages de pêche à retirer : dans notre étude, les passages 2 et 3 sont retirés. 


## Chargement des packages et des données 

```{r chargement_des_packages_et_donnees}
#devtools::install_github("PascalIrz/aspeQual") # Instalation du package 'aspeQual'

## Chargement des packages ----
library(aspe)
library(aspeQual)
library(tidyverse)
library(ggplot2)
library(readxl)

## Chargement des données ----
load(file = "../processed_data/selection_pop_ope.rda")
load(file = "../processed_data/analyse_selection_especes.rda")

rdata_tables <- misc_nom_dernier_fichier(
  repertoire = "../../../../projets/ASPE/raw_data/rdata",
  pattern = "^tables")
load(rdata_tables)

mei_table <- misc_nom_dernier_fichier(
  repertoire = "../../../../projets/ASPE/raw_data/rdata",
  pattern = "^mei")
load(mei_table)

## Lire le fichier Excel contenant les tailles à maturité des espèces
traits_biologiques <- read_excel("../raw_data/traits_biologiques.xlsx")

```


# Constitution du jeu de données

## Selection des tailles de maturité des espèces : 

Les tailles de maturité ont été calculées à partir de 5 sources différentes* pour chacune des espèces et une moyenne sur ces valeurs a été retenue pour être inscrite comme valeur de référence de maturité.

*1 et 2 : ouvrages d'identification des poissons d'eau douce de France ; 
3 : observation des courbes de tailles dans le fichier R "estimation_taille_0+" à partir des données de taille du fichier ASPE ; 
4 : Valeurs de "fishbase" ; 
5 : Valeurs de référence de l'Occitanie


```{r construction_df_tailles_maturite}
# Construction d'un dataframe contenant les tailles de maturité calculées : 
traits_biologiques <- traits_biologiques %>% 
  select(esp_code_alternatif,
         espece_presence_lrr_2015,
         taille_maturite)
```


## Création d'un dataframe

Création d'un dataframe contenant les données individuelles relatives aux opérations contenues dans la passerelle et de ma sélection d'espèces (cf 00_selection_pop_ope et 03_analyse_selection_especes). La taille des poissons est indiquée en mm et le poids en gramme. 

```{r creation_df_mei_ope_selection}
# Ajout des mesures individuelles en partant de mes mei_ope_selection ----
mei_ope_selection <- passerelle %>%
  mef_ajouter_ope_date() %>% 
  mef_ajouter_mei() %>%
  mef_ajouter_lots() %>% 
  mef_ajouter_type_protocole() %>% 
  mef_ajouter_passage() %>% 
  mef_ajouter_type_lot() %>% 
  mef_ajouter_type_longueur() %>% 
  select(ope_id,
         lop_id,
         lop_effectif,
         esp_code_alternatif,
         mei_id,
         sta_id,
         pop_id,
         mei_taille,
         pas_numero,
         tyl_libelle,
         pro_libelle,
         annee,
         tlo_libelle)
```

Nous ne retenons que les données en lien avec le dataframe esp_ope_selection et enlevons les passages >1 qui ne seront pas étudiés : Suppression des passages, des répétitions et des lots non souhaités du jeu de données :


```{r pre-traitement donnees}
mei_ope_selection <- mei_ope_selection %>% 
  filter(!pas_numero %in% params$passage_a_retirer) %>% 
  mutate(pas_numero = replace_na(pas_numero,0)) %>% 
  distinct() %>% 
  mutate(esp_code_alternatif = 
           case_when(
             esp_code_alternatif == "VAN" ~ "VAR",
             esp_code_alternatif %in% c("CCX", "CMI", "CCU") ~ "CCO",
             TRUE ~ esp_code_alternatif))
```



Je sélectionne les espèces présentes dans la liste rouge régionale de 2015 :

```{r selection_especes_lrr_2015}
mei_ope_selection <- mei_ope_selection %>% 
  left_join(traits_biologiques) %>% 
  filter(espece_presence_lrr_2015 == "1")
```


## Données Manquantes

On observe dans le jeu de données des potentielles valeurs absentes / manquantes. Ceci peut être dû à des problèmes de retranscription dans la base de données ASPE. Parfois on observe une absence de marquage de valeurs individuelles. Ces valeurs manquantes sont regroupées dans un dataframe "valeur_na". Une taille médiane par espèce et station est assignée en cas de données manquantes.

```{r, Regroupement des valeurs NA}
#Sélection des lignes contenant une valeur de taille NA
valeur_na <- mei_ope_selection %>%
  filter(if_any(everything(), is.na))

mei_ope_selection <- na.omit(mei_ope_selection)
```


```{r, Remplacement des valeurs NA}
# Un dataframe contenant les tailles médiannes des espèces par station est créer 
sta_tableau_reference_taille <- mei_ope_selection %>%
  group_by(sta_id,
           esp_code_alternatif) %>%
  summarise(mei_taille = median(mei_taille, na.rm = TRUE)) %>%
  ungroup()

# Remplacement des valeurs de tailles manquantes par les valeurs du tableau de référence
valeur_na_complet <- valeur_na %>%
  left_join(sta_tableau_reference_taille, by = c("sta_id", "esp_code_alternatif")) %>% 
  select(-mei_taille.x) %>% 
  rename(mei_taille = mei_taille.y)

#Constitution du df "mei_ope_selection" complet
mei_ope_selection <- bind_rows(mei_ope_selection, valeur_na_complet)

```



## Distinction des classes d'âges

En complément de la base ASPE, un tableau indiquant pour chaque espèce la taille maximale des 0+ est constitué (= taille référence minimum adulte). La longueur du poisson est utilisé comme proxy de son age.  Une distinction des classes d'âges est réalisée : à chaque espèce correspond alors 3 stades différents : 
- Adulte (individus dont la taille est supérieure à la taille_min_adulte)
- Juvénile (individus dont la taille est inférieure à la taille_min_adulte)
- Indifférencié : toutes classes d'âge confondues (ad + juv)


```{r distinction_classes_ages}
# Ajout du stade par individus ----
mei_ope_selection <- mei_ope_selection %>% 
  mutate(stade = ifelse(mei_ope_selection$mei_taille < mei_ope_selection$taille_maturite,
                         "juv",
                         "ad"))
```




# Qualité des données individuelles (tailles / poids)

Maintenant que nous avons toutes les données regroupées dans un dataframe général nous pouvons passer au traitement qualitatif des données individuelles des poissons et notamment des valeurs de poids et de tailles. 

Mise en place des relations tailles / poids pour ne plus avoir de données manquantes : 

```{r Traitement qualité données}
# Utilisation des relations taille - poids du package aspe

mei_taille_poids <- aspe::data_taille_poids %>%
  group_by(esp_code_alternatif,
           tlo_libelle) %>%
  arrange(source) %>%
  slice(1)
  

# nb : vérifier qu'on a bien les tailles pour tous les poissons avant d'appliquer la taille-poids
# combinaisons espèces - type de longueur absentes de la table de conversion
  
mei_tp_manquantes <- mei_ope_selection %>%
  select(esp_code_alternatif,
         tlo_libelle) %>%
  distinct() %>%
  left_join(y = mei_taille_poids) %>%
  filter(is.na(a))
  

# nb : certaines espèces n'ont pas de relation en longueur fourche, on approxime par la longueur totale
  
mei_esp_tp_manquantes <- mei_tp_manquantes %>%
  pull(esp_code_alternatif)
  

mei_ope_selection <- mei_ope_selection %>%
  mutate(tlo_libelle = ifelse(
      esp_code_alternatif %in% mei_esp_tp_manquantes &
        tlo_libelle == "Fourche", "Totale",
      tlo_libelle
    ))
  
mei_ope_selection <- mei_ope_selection %>%
  left_join(y = mei_taille_poids,
            by = c("esp_code_alternatif", "tlo_libelle")) %>%
  mutate(poids_tp = a * ((mei_taille / 10) ^ b))

```


Mise en place de seuils pour détecter des erreurs potentielles dans la base de données constituée : 

```{r ajout_mesures_poids}
# On ajoute les mesures de poids existantes 
mei_ope_selection <- mei_ope_selection %>% 
  mef_ajouter_mei() %>% 
  select(ope_id:poids_tp, mei_poids)

esp_lt_data <- mei_ope_selection %>%
  ungroup() %>% 
  filter(tlo_libelle == "Totale",
         esp_code_alternatif == esp_code_alternatif)
```

Calcul des seuils de taille minimum et maximum pour chaque espèce : 

```{r Taille min et max especes}
mei_df_seuils <- aspeQual::qtp_seuils(df = esp_lt_data,
                                      var_taxon = esp_code_alternatif,
                                      var_a_tester = mei_taille,
                                      seuil_densite = 0.001)
```


```{r Jointure seuils}
# Joindre les seuils calculés avec le jeu de données principal
mei_ope_selection <- mei_ope_selection %>%
  left_join(mei_df_seuils, by = "esp_code_alternatif")

```


"erreur_df" rencense l'ensemble des données abérantes du jeu de données. Il est nécessaire de les corriger directement dans la base ASPE s'il s'agit de véritables erreurs de saisies. 


```{r detection erreurs}
detecter_erreurs <- function(df) {
  # Filtrer les données où les valeurs de mei_taille sont en dehors des seuils
  erreurs <- filter(df, mei_taille < mini | mei_taille > maxi) %>% 
    select(ope_id, esp_code_alternatif, mei_id, mini, maxi, mei_taille)
  
  if (nrow(erreurs) > 0) {
    message("Les données suivantes ont des valeurs de mei_taille en dehors des seuils :")
    print(erreurs)
    return(erreurs)  # Retourne le dataframe des erreurs
  } else {
    message("Aucune erreur détectée.")
    return(NULL)  # Retourne NULL s'il n'y a pas d'erreur
  }
}

erreurs_df <- detecter_erreurs(df = mei_ope_selection)

```



# Sauvegarde

```{r sauvegarde}
# SAUVEGARDE ----
save(mei_ope_selection,
     file = "../processed_data/pre_traitements_donnees_especes.rda")
```

