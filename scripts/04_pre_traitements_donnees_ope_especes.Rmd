---
title: "Liste Rouge Régionale des poissons d'eau douce de Bretagne"
subtitle: "Prétraitement des données opération et des données individuelles des espèces"
author: "OFB Bretagne"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
params:
  passage_a_retirer: !r c("2","3") # Sélection du nombre de passage souhaité ; Remarque : si je souhaite enlever les 1ers passages, sélection "0","1" 
  type_lot_a_retirer: !r c("G") # Sélection des lots à retirer du jeu de données ; tyl_libelle  = G (cf ref_type_lot)
  type_peche_a_inclure: !r c("Pêche complète à un ou plusieurs passages",
                            "Pêche partielle par points (grand milieu)",
                            "Pêche par ambiances",
                            "Pêche partielle sur berge") # Selection des types de pêches à inclure au jeu de données (pro_libelle)
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
```

# Objectif : Dynamique de population des poissons d'eau douce de Bretagne - 04_pre_traitements_donnees_ope_especes

Il s'agit ici de réaliser une étape de pré-traitement sur la sélection des opérations et sur les données des espèces propres à chacune des opérations. Il s'agit notamment d'observer les valeurs abérrantes contenues dans les mesures individuelles des différentes espèces de poissons d'eau douce. Il s'agit donc également d'une mise en qualité des données (tailles / poids) par individu de poissons pêchés. 

# Installation 

## Paramètres 

Plusieurs paramètres sont fixés au début du scripts : ces paramètres sont modifiables selon les préférences et les objectifs visés. Parmi ces paramètres :

- Sélection des passages de pêche à retirer : dans notre étude, les passages 2 et 3 sont retirés. 

- Sélection des types de lots à retirer : dans notre étude, le type de lot "G" n'est pas souhaité.

- Les types de pêches : Il existe de nombreux types de pêches : pêche partielle par point, pêche par ambiance,.... Ce paramètre permet de sélectionner les types de pêches souhaitées dans l'étude. 



## Chargement des packages et des données 

```{r chargement_des_packages_et_donnees}
#devtools::install_github("PascalIrz/aspeQual")

## Chargement des packages ----
library(aspe)
library(aspeQual)
library(tidyverse)
library(ggplot2)
library(readxl)

## Chargement des données ----
load(file = "../processed_data/selection_pop_ope.rda")
load(file = "../processed_data/analyse_selection_especes.rda")

rdata_tables <- misc_nom_dernier_fichier(
  repertoire = "../../../../projets/ASPE/raw_data/rdata",
  pattern = "^tables")
load(rdata_tables)

mei_table <- misc_nom_dernier_fichier(
  repertoire = "../../../../projets/ASPE/raw_data/rdata",
  pattern = "^mei")
load(mei_table)

## Lire le fichier Excel contenant les tailles à maturité des espèces
traits_biologiques <- read_excel("C:/Users/lea.bouchet/Documents/Artif/Artif/liste_rouge_regionale/scripts/taille_maturite_especes/traits_biologiques.xlsx")

## Chargement des fonctions 
source(file = "../R/calcul_seuils.R")
```


# Constitution du jeu de données

## Selection des tailles de maturité des espèces : 

ATTENTION : Ici les tailles de maturité ne sont pas définitives (vérif Thibault). Elles ont été calculées à partir de 5 sources différentes (1 et 2 : ouvrages d'identification des poissons d'eau douce de France); 3 : observation des courbes de tailles dans le fichier R "estimation_taille_0+" à partir des données de taille du fichier ASPE ; 4 : les valeurs dans fishbase ; 5 : les valeurs de référence de l'occitanie). 


```{r construction_df_tailles_maturite}
# Construction d'un dataframe contenant les tailles de maturité calculées : 
traits_biologiques <- traits_biologiques %>% 
  select(esp_code_alternatif,
         espece_presence_lrr_2015,
         taille_maturite)
```


## Création d'un dataframe

Création d'un dataframe contenant les données individuelles relatives aux opérations contenues dans la passerelle et de ma sélection d'espèces (cf 00_selection_pop_ope et 03_analyse_selection_especes).  

```{r creation_df_mei_ope_selection}
# Ajout des mesures individuelles en partant de mes mei_ope_selection ----
mei_ope_selection <- passerelle %>%
  mef_ajouter_ope_date() %>% 
  mef_ajouter_mei() %>%
  mef_ajouter_lots() %>% 
  mef_ajouter_type_protocole() %>% 
  mef_ajouter_passage() %>% 
  mef_ajouter_type_lot() %>% 
  mef_ajouter_type_longueur() %>% 
  select(ope_id,
         lop_id,
         lop_effectif,
         esp_code_alternatif,
         mei_id,
         sta_id,
         pop_id,
         mei_taille,
         pas_numero,
         tyl_libelle,
         pro_libelle,
         annee,
         tlo_libelle)
```

Sélection des espèces présentes dans la liste rouge régionale 2015 :

```{r selection_especes_lrr_2015}
lop_esp_selection <- lop_esp_selection %>% 
  left_join(traits_biologiques) %>% 
  filter(espece_presence_lrr_2015 == "1")
```

Suppression des passages, des répétitions et des lots non souhaités du jeu de données

```{r pre_traitements_mei_ope_selection}
mei_ope_selection <- mei_ope_selection %>% 
  filter(!pas_numero %in% params$passage_a_retirer,
         pro_libelle %in% params$type_peche_a_inclure,
         !tyl_libelle%in% params$type_lot_a_retirer) %>% 
  distinct() %>% 
  left_join(lop_esp_selection) %>% 
  mutate(lop_esp_code_alternatif = ifelse (test = esp_code_alternatif == "VAN",
                                       yes = "VAR",
                                       no = esp_code_alternatif)) %>% 
  mutate(lop_esp_code_alternatif = ifelse (test = esp_code_alternatif == "CCX",
                                           yes = "CCO",
                                           no = esp_code_alternatif)) 

# Remplacement des passages = "NA" en "0" (= premier et unique passage) ----
mei_ope_selection <- mei_ope_selection %>% 
  dplyr::mutate(pas_numero = replace_na(pas_numero,0))

#Suppression des "NA" restants ----
mei_ope_selection <- na.omit(mei_ope_selection)

```



## Distinction des classes d'âges

En complément de la base ASPE, un tableau indiquant por chaque espèce la maximale des 0+ est constitué (et donc la taille référence minimum adulte). On utilise donc la longueur du poisson comme proxy de son age.  Une distinction des classes d'âges est réalisée : a chaque espèce correspond alors 3 statuts différents : 
- Adulte (individus dont la taille est supérieure à la taille_min_adulte)
- Juvénile (individus dont la taille est inférieure à la taille_min_adulte)
- Toutes : toute classe d'e taille'âge confondue


```{r distinction_classes_ages}
# Ajout du statut par individus ----
mei_ope_selection <- mei_ope_selection %>% 
  mutate(statut = ifelse(mei_ope_selection$mei_taille < mei_ope_selection$taille_maturite,
                         "juvénile",
                         "adulte"))
```


# Qualité des données individuelles (tailles / poids)

Maintenant que nous avons toutes les données regroupées dans un dataframe général nous pouvons passer au traitement qualitatif des données individuelles des poissons et notamment des valeurs de poids et de tailles. 

Mise en place des relations tailles / poids pour ne plus avoir de données manquantes : 

```{r}
# Utilisation des relations taille - poids du package aspe

mei_taille_poids <- aspe::data_taille_poids %>%
  group_by(esp_code_alternatif,
           tlo_libelle) %>%
  arrange(source) %>%
  slice(1)
  

# nb : vérifier qu'on a bien les tailles pour tous les poissons avant d'appliquer la taille-poids
# combinaisons espèces - type de longueur absentes de la table de conversion
  
mei_tp_manquantes <- mei_ope_selection %>%
  select(esp_code_alternatif,
         tlo_libelle) %>%
  distinct() %>%
  left_join(y = mei_taille_poids) %>%
  filter(is.na(a))
  

# nb : certaines espèces n'ont pas de relation en longueur fourche, on approxime par la longueur totale
  
mei_esp_tp_manquantes <- mei_tp_manquantes %>%
  pull(esp_code_alternatif)
  

mei_ope_selection <- mei_ope_selection %>%
  mutate(tlo_libelle = ifelse(
      esp_code_alternatif %in% mei_esp_tp_manquantes &
        tlo_libelle == "Fourche", "Totale",
      tlo_libelle
    ))
  
mei_ope_selection <- mei_ope_selection %>%
  left_join(y = mei_taille_poids,
            by = c("esp_code_alternatif", "tlo_libelle")) %>%
  mutate(poids_tp = a * ((mei_taille / 10) ^ b))

```


Mise en place de seuils pour détecter des erreurs potentielles dans la base de données constituée : 

```{r ajout_mesures_poids}
# On ajoute les mesures de poids existantes 
mei_ope_selection <- mei_ope_selection %>% 
  mef_ajouter_mei() %>% 
  select(ope_id:poids_tp, mei_poids)

esp_lt_data <- mei_ope_selection %>%
  ungroup() %>% 
  filter(tlo_libelle == "Totale",
         esp_code_alternatif == esp_code_alternatif)
```


Réalisation de la fonction calcul_seuil : 

```{r}

source(file = "../R/calcul_seuils.R")

test <- qtp_seuils2(df = esp_lt_data#,
                      # var_taxon = esp_code_alternatif,
                      # var_a_tester = mei_taille
                    )

mes_especes <- unique(esp_lt_data$esp_code_alternatif)

test <- qtp_seuils2(df = esp_lt_data,
            code_espece = mes_especes[1])

test2 <- map(.x = mes_especes,
                .f = qtp_seuils2,
                df = esp_lt_data)
```




```{r}
# Création d'une liste pour stocker les données des seuils pour chaque espèce
seuils_list <- list()

# Boucle pour calculer les seuils min et max pour chaque espèce

for (code in unique(esp_lt_data$esp_code_alternatif)) {
  # Filtrer les données pour l'espèce actuelle
  esp_data <- filter(esp_lt_data, esp_code_alternatif == code)
  
  # Calculer les seuils pour l'espèce actuelle
  seuils <- aspeQual::qtp_seuils(
    df = esp_data,
    code_espece = code,
    variable = "mei_taille",
    seuil_densite = 0.001
  )
  
  # Stocker les seuils min et max dans une liste
  seuils_list[[code]] <- data.frame(
    esp_code_alternatif = code,
    seuil_min = min(seuils),
    seuil_max = max(seuils)
  )
}

# Combiner les données des seuils pour chaque espèce en un seul DataFrame
mei_df_seuils <- do.call(rbind, seuils_list)

# Joindre les seuils calculés avec le jeu de données principal
mei_ope_selection <- mei_ope_selection %>%
  left_join(mei_df_seuils, by = "esp_code_alternatif")

```

```{r}
detecter_erreurs <- function(mei_ope_selection) {
  # Filtrer les données où les valeurs de mei_taille sont en dehors des seuils
  erreurs <- filter(mei_ope_selection, mei_taille < seuil_min | mei_taille > seuil_max) %>% 
    select(ope_id, esp_code_alternatif, mei_id, seuil_min, seuil_max, mei_taille)
  
  if (nrow(erreurs) > 0) {
    message("Les données suivantes ont des valeurs de mei_taille en dehors des seuils :")
    print(erreurs)
    return(erreurs)  # Retourne le dataframe des erreurs
  } else {
    message("Aucune erreur détectée.")
    return(NULL)  # Retourne NULL s'il n'y a pas d'erreur
  }
}

erreurs_df <- detecter_erreurs(mei_ope_selection)

```

# Sauvegarde

```{r}
# SAUVEGARDE ----
save(mei_ope_selection,
     file = "../processed_data/pre_traitements_donnees_especes.rda")
```

