---
title: "Liste Rouge Régionale des poissons d'eau douce de Bretagne"
subtitle: "Calcul des indicateurs régionaux"
author: "OFB Bretagne"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
```


# Objectif : Dynamique de population des poissons d'eau douce de Bretagne - 11_calcul_indicateurs_regionaux

Pour les indicateurs calculés au point, on agrège chaque année leur valeur à l'échelle régionale. Le taux d'occurence de chaque espèce est directement calculée annuellement, à l'échelle régionale, comme le pourcentage de sites prospectés où l'espèce a été trouvée. 


# Installation 

## Chargement des packages, fonctions et des données 

```{r Chargement des packages, données et fonctions}

## Chargement des packages ----
library(ggthemes)
library(tidyverse)
library(aspe)
library(ggplot2)
library (khroma)
library(dplyr)
library(wesanderson)
library(zoo)
library(lemon)
library(trend)
library(ggh4x)


## Chargement des données ----
load(file = "../processed_data/selection_pop_ope.rda")
load(file = "../processed_data/pre_traitements_donnees_env.rda")
load(file = "../processed_data/assemblage_tab_par_ope.rda")
load(file = "../processed_data/analyse_selection_especes.rda")

# rdata_tables <- misc_nom_dernier_fichier(
#   repertoire = "../../../../projets/ASPE/raw_data/rdata",
#   pattern = "^tables")
# load(rdata_tables)

source(file = "../R/mk_st_by_group.R")
source(file = "../R/mann_kendall_sen.R")
source(file = "../R/calcul_taux_evolution.R")

# Définition des couleurs de l'OFB en format RGB
pal <- c("#007844", "#92D050", "#0087C1", "#FCEE21", "#00AEEF", "#1D1D1B", "#A97B30", "#B9D9EB")
```

# Constitution du jeu de données

### Taux d'occurrence

On calcul le taux d'occurrence des espèces : 

```{r Calcul taux occurrence}
occur <- ope_indicateur %>% 
  filter(stade == "ind",
         indicateur == "effectif_total",
         valeur > 0) %>%
  group_by(annee, esp_code_alternatif) %>% 
  summarise(n_occur = n_distinct(ope_id))

n_ope_par_an <- ope_indicateur %>% 
  filter(stade == "ind",
         indicateur == "effectif_total") %>%
  group_by(annee) %>% 
  summarise(n_ope = n_distinct(ope_id))

taux_occ <- occur %>% 
  left_join(n_ope_par_an) %>% 
  mutate(valeur = n_occur / n_ope,
         indicateur = "taux_occurrence",
         stade = "ind")
```


## Echelle régionale

```{r Calcul ope_ind à l'échelle régionale, fig.height = 55, fig.width = 10}
# Calcul des données par année et pop_id en calculant la médiane de la valeur de l'indicateur ----
reg_indicateur <- ope_indicateur %>%
  group_by(esp_code_alternatif, annee, indicateur, stade) %>%
  summarize(valeur = case_when(
    indicateur == "pourcentage_juveniles" ~ mean(valeur),
    TRUE ~ median(valeur)
  )) %>%
  ungroup() %>%
  distinct()
```

```{r}
taux_occ <- taux_occ %>% 
  select(names(reg_indicateur))

reg_indicateur <- reg_indicateur %>% 
  rbind(taux_occ)

```

```{r, fig.height = 55, fig.width = 10}
# Représentation graphique des données : 

graphique <- reg_indicateur %>% 
  ggplot(aes(x= annee, y =valeur, group = stade, color = stade)) + 
  geom_point() +
  geom_smooth(se = FALSE) +
  facet_grid2(esp_code_alternatif ~ indicateur, scales = "free", independent = "y") + 
  scale_color_manual(values = c("juv" = "#92D080", "ad" = "#A97B30", "ind" = "black"),
                     name = "Stade", labels = c("Adulte", "Indeterminé", "Juvénile")) +
  labs(title = "Indicateurs de tendances à l'échelle régionale des espèces de poissons d'eau douce",
       x = "Années", 
       y = "Valeurs") +
  theme_bw()+
  theme(strip.background = element_rect(color = "black", fill = "#faffff"),
        legend.position = "bottom",
        panel.background = element_rect(fill="#faf0e0"),
        panel.grid.major = element_line(color="lightgrey", size = 0.1),
        panel.grid.minor = element_line(color = "lightgrey"),
        axis.text.x = element_text(angle = 45))

print(graphique)

```


## Tendances globales 

Il s'agit d'observer les différentes tendances présentes sur les indicateurs précedement établis. 

```{r, fig.height = 25, fig.width = 10}
tendance_indicateur <- mk_st_by_group(ope_indicateur,
                                      var_x = annee,
                                      var_y = valeur,
                                      esp_code_alternatif,
                                      indicateur,
                                      stade, 
                                      pop_id)
```



```{r, fig.height = 25, fig.width = 10}
tendance_indicateur %>% 
  filter(indicateur!="taux_occurrence",
         stade == "ad") %>% 
  group_by(indicateur,
           trend,
           stade,
           esp_code_alternatif) %>% 
  summarise (n = n_distinct (pop_id)) %>% 
  ggplot(mapping = aes(x = trend,
                       y = n,
                       fill = trend)) +
  geom_bar(stat="identity") +
  facet_grid(~esp_code_alternatif ~ stade ~ indicateur  , 
              scales = "free") +
  labs(title = "Tendances indicateurs - Adulte", 
       x = "Tendance", 
       y = "Valeurs pop_id") +
  scale_fill_manual(values = c("Decrease" = "red","Increase" = "#92D080", "No trend" ="lightgrey"),
                     name = "Tendance : ") +
  theme(strip.background = element_rect(color = "black", fill = "#faffff"),
        panel.grid.major = element_line(color="#ffffff", size = 0.1),
        panel.grid.minor = element_line(color = "#ffffff"),
        panel.background = element_rect(fill="#faf0e0"),
        legend.position = "bottom") 
```



```{r, fig.height = 25, fig.width = 10}
tendance_indicateur %>% 
  filter(indicateur!="taux_occurrence",
         stade == "juv") %>% 
  group_by(indicateur,
           trend,
           stade,
           esp_code_alternatif) %>% 
  summarise (n = n_distinct (pop_id)) %>% 
  ggplot(mapping = aes(x = trend,
                       y = n,
                       fill = trend)) +
  geom_bar(stat="identity") +
  facet_grid(~esp_code_alternatif ~ stade ~ indicateur  , 
              scales = "free") +
  labs(title = "Tendances indicateurs - Juvénile", 
       x = "Tendance", 
       y = "Valeur pop_id") +
  scale_fill_manual(values = c("Decrease" = "red","Increase" = "#92D080", "No trend" ="lightgrey"),
                     name = "Tendance : ") +
  theme(strip.background = element_rect(color = "black", fill = "#faffff"),
        panel.grid.major = element_line(color="#ffffff", size = 0.1),
        panel.grid.minor = element_line(color = "#ffffff"),
        panel.background = element_rect(fill="#faf0e0"),
        legend.position = "bottom") 

```


```{r, fig.height = 25, fig.width = 10}
tendance_indicateur %>% 
  filter(indicateur!="taux_occurrence",
         stade == "ind") %>% 
  group_by(indicateur,
           trend,
           stade,
           esp_code_alternatif) %>% 
  summarise (n = n_distinct (pop_id)) %>% 
  ggplot(mapping = aes(x = trend,
                       y = n,
                       fill = trend)) +
  geom_bar(stat="identity") +
  facet_grid(~esp_code_alternatif ~ stade ~ indicateur  , 
              scales = "free") +
  labs(title = "Tendances indicateurs - Indéterminé", 
       x = "Tendance", 
       y = "Valeur pop_id") +
  scale_fill_manual(values = c("Decrease" = "red","Increase" = "#92D080", "No trend" ="lightgrey"),
                     name = "Tendance : ") +
  theme(strip.background = element_rect(color = "black", fill = "#faffff"),
        panel.grid.major = element_line(color="#ffffff", size = 0.1),
        panel.grid.minor = element_line(color = "#ffffff"),
        panel.background = element_rect(fill="#faf0e0"),
        legend.position = "bottom") 
```


### Taux d'Evolution

On souhaite calculer le taux d'évolution inter-annuel, c'est à dire entre l'année n et l'année n-1, par espèce. Si le taux d'évolution est positif, cela correspond à une croissance de la population ; si il est négatif, cela correspond à un déclin. 

```{r}
# Taux d'évolution du taux d'occurence de densité de surface : 

taux_evol_1990 <- calcul_taux_evol(df = reg_indicateur,
                             var_x = annee,
                             var_y = valeur,
                             debut = 1990,
                             esp_code_alternatif,
                             stade,
                             indicateur)
print(taux_evol_1990)

```



```{r, fig.height = 25, fig.width = 10}
# Définition des seuils et des couleurs correspondantes
seuils <- c(0.35, 0.99, 1.01, 1.25)
couleurs <- c("#CB2027", "#DDDDDD","#8fd175")
n <- length(seuils)

# Représentation graphique :
graph_taux_evol <- taux_evol_1990 %>%
  ggplot(aes(x = reorder(stade, mean_geom), y = mean_geom, color = stade)) +
  geom_point(shape = 19) +
  geom_line(aes(group = stade)) +
  facet_grid(~ esp_code_alternatif ~ indicateur, scales = "free") +
  labs(title = "Taux évolution", x = "Stade", y = "Moyenne Géométrique") +
  theme(strip.background = element_rect(color = "black", fill = "#faffff"),
        panel.grid.major = element_line(color = "#ffffff", size = 0.1),
        panel.grid.minor = element_line(color = "#ffffff"),
        panel.background = element_rect(fill = "#faf0e0"),
        legend.position = "bottom") + 
  scale_color_manual(values = c("juv" = "#92D080", "ad" = "#A97B30", "ind" = "black"),
                     name = "Stade", labels = c("Adulte", "Indeterminé", "Juvénile"))



for (i in 1:(n-1)) {
  graph_taux_evol <- graph_taux_evol +
    annotate("rect", xmin = -Inf, xmax = Inf, ymin = seuils[i], ymax = seuils[i+1], fill = couleurs[i], alpha = 0.1)
}

print(graph_taux_evol)

```


```{r}
indicateur_sel <- "effectif_total"

taux_evol_eff <- taux_evol_1990 %>% 
  filter (indicateur == indicateur_sel,
          stade == "ind")



tendance_indicateur_eff <- tendance_indicateur %>% 
  filter (indicateur == indicateur_sel,
          stade == "ind") %>% 
  select(-pop_id) %>% 
  group_by(esp_code_alternatif) %>% 
  mutate(med_Sen = median(sens_slope))

tendance_indicateur_eff <- tendance_indicateur_eff %>% 
  left_join(taux_evol_eff) %>% 
  select (esp_code_alternatif,
          mean_geom,
          med_Sen) %>% 
  unique()
```


Observation de ce qu'il se passe au niveau des taux d'évol
```{r}
tendance_indicateur_gra <- tendance_indicateur_eff %>% 
  filter(!esp_code_alternatif %in% c("FLE", "MUP", "PLI", "LPR", "ALF" )) %>%  # On retire les espèces qui ont trop peu de données pour être évaluées
  ggplot(aes(x = mean_geom, y = med_Sen,  label = esp_code_alternatif)) +
  geom_smooth(method = "lm", se = TRUE) + 
  geom_point() + 
  geom_hline(yintercept = 0,
             linetype = "dotted")+
  geom_vline(xintercept = 1,
             linetype = "dotted")+
 # geom_text(hjust = 0.5, vjust = 1.3) + 
  ggrepel::geom_text_repel()
 

print(tendance_indicateur_gra)
```



Je travail ici sur des modèles linéiares généralisés :

```{r}
data <- ope_selection %>% 
  select(ope_id,
         pro_libelle) 

ope_indicateur <- ope_indicateur %>% 
  mutate (valeur_l = ifelse (grepl("densite", indicateur),
                               log(1 + valeur),
                               valeur)) %>%  
  left_join(data)

source(file = "../R/calcul_glm.R") 

mon_espece <- "ANG"
mon_stade <- "ind"
mon_indicateur <- "densite_surface"

test_data_ang_ind <- ope_indicateur %>% 
  ungroup() %>% 
  filter(indicateur == mon_indicateur,
         esp_code_alternatif == mon_espece,
         stade == mon_stade)

test_ang_ind <- calcul_glm_non_groupe(test_data_ang_ind)
test_ang_ind <- test_ang_ind %>% 
  mutate(esp_code_alternatif = "ANG",
         stade = "ind",
         indicateur = "densite_surface")



mon_espece <- "ABL"
mon_stade <- "ind"
mon_indicateur <- "densite_surface"

test_data_abl_ind <- ope_indicateur %>% 
  ungroup() %>% 
  filter(indicateur == mon_indicateur,
         esp_code_alternatif == mon_espece,
         stade == mon_stade)

test_abl_ind <- calcul_glm_non_groupe(test_data_abl_ind)
test_abl_ind <- test_abl_ind %>% 
  mutate(esp_code_alternatif = "ABL",
         stade = "ind",
         indicateur = "densite_surface")



mon_espece <- "BRB"
mon_stade <- "ind"
mon_indicateur <- "densite_surface"

test_data_brb_ind <- ope_indicateur %>% 
  ungroup() %>% 
  filter(indicateur == mon_indicateur,
         esp_code_alternatif == mon_espece,
         stade == mon_stade)

test_brb_ind <- calcul_glm_non_groupe(test_data_brb_ind)
test_brb_ind <- test_brb_ind %>% 
  mutate(esp_code_alternatif = "BRB",
         stade = "ind",
         indicateur = "densite_surface")



mon_espece <- "BRB"
mon_stade <- "ind"
mon_indicateur <- "densite_surface"

test_data_brb_ind <- ope_indicateur %>% 
  ungroup() %>% 
  filter(indicateur == mon_indicateur,
         esp_code_alternatif == mon_espece,
         stade == mon_stade)

test_brb_ind <- calcul_glm_non_groupe(test_data_brb_ind)
test_brb_ind <- test_brb_ind %>% 
  mutate(esp_code_alternatif = "BRB",
         stade = "ind",
         indicateur = "densite_surface")

```


Je fais tourner des modèles linéaires simples (ou glm) sur ope_indicateur : 

```{r}

calcul_glm_non_groupe <- function(df) {
  # Vérifier si le nombre d'observations est suffisant pour ajuster le modèle
  if (nrow(df) < 2) {
    return(NULL)  # Retourner NULL si le nombre d'observations est insuffisant
  }
  
  # Ajuster le modèle GLM
  model <- glm(formula = valeur_l ~ annee,
               data = df,
               family = "gaussian")
  
  # Autres opérations comme l'élimination des outliers
  
  # Vérifier si le modèle a convergé avec succès et que les coefficients sont valides
  if (inherits(model$coefficients, "numeric") && length(model$coefficients) == 2) {
    # Le modèle a convergé avec succès et a des coefficients valides
    result <- data.frame(
      intercept = model$coefficients[["(Intercept)"]],
      annee = ifelse(model$coefficients[["annee"]] != 0, model$coefficients[["annee"]], "Nul"),
      pvalue = as.data.frame(summary(model)$coefficients) %>%
        rownames_to_column() %>%
        filter(rowname == "annee") %>%
        pull(`Pr(>|t|)`)
    )
  } else {
    # Le modèle n'a pas convergé ou les coefficients sont invalides
    result <- data.frame(
      intercept = NA,
      annee = NA,
      pvalue = NA
    )
  }
  
  return(result)
}

# Fonction pour calculer les GLM pour chaque combinaison d'espèce, indicateur et stade
calcul_glm_par_groupe <- function(ope_indicateur) {
  ope_indicateur %>%
    group_by(esp_code_alternatif, 
             indicateur,
             stade) %>%
    summarize(glm_result = if(n() >= 2) list(calcul_glm_non_groupe(cur_data())) else NULL)
}

# Appliquer la fonction à votre dataframe
resultats <- calcul_glm_par_groupe(ope_indicateur)

# Maintenant, resultats contient les résultats des modèles GLM pour chaque combinaison d'espèce, indicateur et stade
# Vous pouvez accéder aux résultats comme suit :
resultats



```


ici c'est une version où tout apparait directement dans un dataframe

```{r}

library(dplyr)

# Fonction pour calculer les GLM pour chaque combinaison d'espèce, indicateur et stade
calcul_glm_par_groupe <- function(ope_indicateur) {
  resultats1 <- lapply(split(ope_indicateur, list(ope_indicateur$esp_code_alternatif, ope_indicateur$indicateur, ope_indicateur$stade)), function(df) {
    # Vérifier si le nombre d'observations est suffisant pour ajuster le modèle
    if (nrow(df) < 2) {
      return(NULL)  # Retourner NULL si le nombre d'observations est insuffisant
    }
    
    # Ajuster le modèle GLM
    model <- glm(formula = valeur_l ~ annee,
                 data = df,
                 family = "gaussian")
    
    # Autres opérations comme l'élimination des outliers
    
    # Récupérer les résultats du modèle
    result <- data.frame(
      esp_code_alternatif = unique(df$esp_code_alternatif),
      stade = unique(df$stade),
      indicateur = unique(df$indicateur),
      intercept = ifelse(length(model$coefficients) > 0, model$coefficients[["(Intercept)"]], NA),
      annee = ifelse(length(model$coefficients) > 1, model$coefficients[["annee"]], NA),
      pvalue = ifelse(length(model$coefficients) > 1, summary(model)$coefficients["annee", "Pr(>|t|)"], NA)
    )
    return(result)
  })
  
  # Filtrer les résultats pour enlever les valeurs NULL
  resultats1 <- Filter(function(x) !is.null(x), resultats1)
  
  # Convertir la liste en dataframe
  resultats1 <- do.call(rbind, resultats1)
  
  return(resultats1)
}

# Appliquer la fonction à votre dataframe
resultats1 <- calcul_glm_par_groupe(ope_indicateur)

# Maintenant, resultats contient les résultats des modèles GLM pour chaque combinaison d'espèce, indicateur et stade
resultats1

```

