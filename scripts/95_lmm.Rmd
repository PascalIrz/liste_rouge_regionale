---
title: "Liste Rouge Régionale des poissons d'eau douce de Bretagne"
subtitle: "Modèles Linéaires Mixtes"
author: "OFB Bretagne"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
```

# Objectif : Dynamique de population des poissons d'eau douce de Bretagne

Script : 95_LMM

Ce script a pour objectif d'evaluer l'impact qu'ont les différents réseaux sur les tendances des indicateurs régionaux. Il a également l'objectif de regarder l'impact des changements de protocoles sur les stations au cours des années d'études grâce aux modèles linéaires mixtes. 


# Installation 

## Chargement des packages, fonctions et des données 

```{r Chargement des packages}
## Chargement des packages ----
library(ggthemes)
library(tidyverse)
library(aspe)
library(lme4)
library(lmerTest)
library(car)
library(flextable)
library(purrr)
library(broom)
library(ggstats)
library(parameters)
library(ggstatsplot)
```

```{r Chargement des tables ASPE }
## Chargement des tables ASPE ----
rdata_tables <- misc_nom_dernier_fichier(
  repertoire = "../../../../projets/ASPE/raw_data/rdata",
  pattern = "^tables")
load(rdata_tables)

mei_table <- misc_nom_dernier_fichier(
  repertoire = "../../../../projets/ASPE/raw_data/rdata",
  pattern = "^mei")
load(mei_table)
```

```{r Chargement des données}
## Chargement des données ----
load(file = "../processed_data/calcul_indicateurs_regionaux.rda")
load(file = "../processed_data/selection_pop_ope.rda")
load(file = "../processed_data/lm_mann_kendall_tendances.rda")
```

```{r Chargement des fonctions}
source(file = "../R/lmm_calcul_modele.R")
source(file = "../R/lmm_application_modele.R")
source(file = "../R/lm_application_modele.R")
source(file = "../R/lm_calcul_modele.R")
```


# Modèles Linéaires Mixtes (MLM)

## Introduction

Nous utiliserons dans cette étude le package *lme4* pour ajuster des modèles mixtes. La fonction *lmer* de ce package estime les paramètres d’un modèle linéaire mixte. Les formules utilisées par *lmer* suivent la forme *reponse ~ predicteurs*, avec une syntaxe spécifique pour les effets aléatoires.


## Modèles linéaires mixtes dans R 

Dans notre étude, *pop_id* est la variable contenant les identifiants des groupes dans le jeu de données *ope_indicateur_glmm_ex*. Le terme (1 + obj_libelle | pop_id ) indique de modéliser un effet aléatoire du groupe *pop_id* pour l’ordonnée à l’origine (codée “1”) et le coefficient de *obj_libelle*. Si seule l’ordonnée à l’origine variait par groupe, donc si la pente de *valeur* vs. *obj_libelle* était fixée à une seule valeur pour tous les groupes, on pourrait écrire (1 | *pop_id*). *pro_libelle* est un prédicteur définis au niveau du groupe, il apparait donc dans la formule comme n'importe quel autre prédicteur.


# Pré-traitement 

Afin d'appliquer les modèles MLM, il est nécessaire de construire un jeu de données contenant les valeurs des indicateurs, les espèces, les stades, les *pop_id*, mais aussi les types de réseaux et les protocoles de pêches. Nous utilisons dans un premier temps, le jeu de données relatifs aux opérations de pêches (*ope_indicateur*) car nous souhaitons observer les effets des réseaux et des protocoles sur les résultats à l'opération. 


```{r Création dataframe ope_indicateur_glm}
# Création d'un df complet pour l'application des modèles GLM
ope_indicateur_lmm <- ope_indicateur %>%
  filter(indicateur%in% c("biomasse","densite_surface","effectif_total","pourcentage_juveniles")) %>% # Sélection des indicateurs à étudier
  rename(espece = esp_code_alternatif) %>%
  mef_ajouter_objectif() %>%
  mef_ajouter_type_protocole() %>% 
  filter (!obj_libelle == "DCE – Référence") %>% 
  select(-obj_id)  

ope_indicateur_lmm <- ope_indicateur_lmm %>% # On s'assure que pop_id est bien en factor
  mutate(pop_id = as.factor(pop_id)) %>%
  filter(espece %in% c("ANG","BRO", "CHA", "CHE","PER", "GAR", "GOU", "LOF", "LPP","SAT", "TRF", "VAI", "VAR")) # Sélection des espèces étudiées pour la révision de la LRR

```


Avant de lancer le modèle, il est important de définir la liste des périodes d'études souhaités. Dans le cadre de notre étude, nous souhaitons étudier les différentes périodes d'études imposés par la méthodologie liste rouge (spécifique à chaque espèces) ; ainsi nous distinguons 5 périodes d'études distinctes : 

```{r Etablir les périodes d'études GLM}
liste_periodes_etude <- list(c(2008, 2023), 
                             c(2005, 2023),
                             c(1990, 2023),
                             c(2011, 2023),
                             c(2013, 2023)) # Liste des périodes (chaque période est un vecteur avec l'année de début et l'année de fin)

```



# Application modèles GLM 

## Echelle ope_indicateur

Afin d'excéuter l'analyse, deux fonctions ont été créer : *glm_calcul_modele* (en charge de calculer les valeurs des modèles GLM) et *glm_application_modele* (le but étant d'excécuter la fonction *glm_calcul_modele* pour l'ensemble des combinaisons *periodes-especes-stade-indicateur*). Il est donc nécessaire de charger, dans la partie II d'installation, les deux fonctions. 

```{r Excecution fonctions GLM}
lmm_resultats <- lmm_application_modele(data = ope_indicateur_lmm,
                                        liste_periodes = liste_periodes_etude)
```


#### Je souhaite applqiuer les analyses LMM pour mon choix d'espèces / stades / Indicateurs : 

### Tri des espèces
On ne retient qeue les espcèes pour lesquelles nous avons un fort intérêt (au vu des premières tendances dégagées et dans l'optique de la réactualisation de la LRR). 

```{r Tri espèces}
ope_indicateur_reduit <- ope_indicateur_lmm %>% 
  filter(espece %in% c("ANG","BRO", "CHA", "CHE",
                                    "PER", "GAR", "GOU", "LOF", "LPP",
                                    "SAT", "TRF", "VAI", "VAR"))
```


## Tri dans les indicateurs
On ne retient que les indicateurs les plus pertinents à l'analyse des tendances pour glm.

```{r Tri indicateurs}
ope_indicateur_reduit <- ope_indicateur_reduit %>% 
  filter(!indicateur %in% c("pourcentage_site_presence_esp",
                          "longueur_mediane",
                          "densite_volumique",
                          "effectif_total",
                          "biomasse"),
         stade == "ind")
```


```{r Tri indicateurs}
ope_indicateur_reduit <- ope_indicateur_reduit %>%
  mef_ajouter_type_protocole() %>% 
  mef_ajouter_objectif() %>% 
  filter (!obj_libelle %in% c("DCE – Référence", 
                              "Étude")) %>% 
  unique()%>% 
  select(-obj_id)
  
```


```{r Excecution fonctions GLM}
reg_indicateur_tendances_lmm <- lmm_application_modele(data = ope_indicateur_reduit,
                                                           liste_periodes = liste_periodes_etude)
```


```{r Excecution fonctions GLM}
reg_indicateur_lrr_tendances_lmm <- reg_indicateur_tendances_lmm %>% 
  filter(row_name == "annee") %>% 
  select(periode,
         esp_code_alternatif,
         stade,
         indicateur,
         p_value,
         Estimate,
         sig) %>% 
  mutate(trend = case_when(
      Estimate > 0 ~ "\U2197",
      Estimate < 0 ~ "\U2198",
      TRUE ~ "."))
```


```{r Excecution fonctions GLM}
# Filtrer les données selon les critères spécifiés
reg_indicateur_lrr_tendances_lmm <- reg_indicateur_lrr_tendances_lmm %>%
  filter(
    (esp_code_alternatif == "ANG" & periode == "1990-2023") |
    (esp_code_alternatif %in% c("CHE", "LPP") & periode == "2005-2023") |
    (esp_code_alternatif %in% c("BRO", "LOF") & periode == "2008-2023") |
    (esp_code_alternatif %in% c("VAR", "GAR", "VAI", "PER") & periode == "2011-2023") |
    (esp_code_alternatif %in% c("SAT", "GOU", "TRF", "CHA") & periode == "2013-2023")
  )


```

Explications - https://pmarchand1.github.io/ECL8202/notes_cours/05-Modeles_generalises_mixtes.html


# On réalise un tableau : 
```{r}
tab_reg_indicateur_lrr_tendances_lmm <- reg_indicateur_lrr_tendances_lmm %>%
  select(esp_code_alternatif,
         periode,
         indicateur,
         trend,
         sig) %>% 
  arrange(esp_code_alternatif, 
          indicateur) %>%   # Ordonner par espèce, indicateur et stade
  gt() %>%
  tab_header(
    title = "Synthèse des tendances des indicateurs des populations de poissons d'eau douce de Bretagne"
  ) %>%
  cols_label(
    esp_code_alternatif = "Code Espèce",
    indicateur = "Indicateur",
    trend = "Tendance Regression linéaire",
    sig = "Significativité") %>%
  tab_options(table.font.size = "small", data_row.padding = px(5))

# Afficher le tableau
tab_reg_indicateur_lrr_tendances_lmm
```


# Sauvegarde

```{r}
save(reg_indicateur_lrr_tendances_lmm,
     reg_indicateur_lrr_tendances_lm,
     reg_indicateur_lrr_tendances_mk_st,
     tab_reg_indicateur_lrr_tendances_lmm,
     tab_reg_indicateur_lrr_tendances_lm,
     tab_reg_indicateur_lrr_tendances_mk_st,
     file = "../processed_data/mk_lmm_lm_tendances.rda")
```



A VOIR APRES


## Les histoires de step_aic

```{r}
ope_lmm <- ope_indicateur_tri_final_tendances_LRR %>% 
  filter(espece == "ANG")


lmmm <- lmer(valeur ~ (1 | pop_id) + annee + pro_libelle + obj_libelle, data = ope_lmm)

model_aic <- MASS::stepAIC(lmmm)

```



## Taux d'Evolution

On souhaite calculer le taux d'évolution inter-annuel, c'est à dire entre l'année n et l'année n-1, par espèce. Si le taux d'évolution est positif, cela correspond à une croissance de la population ; si il est négatif, cela correspond à un déclin. 

```{r Calcul des taux evolution}
# Calcul des taux d'évolution depuis 1990


taux_evolution_LRR <- calcul_taux_evol(df = reg_indicateur,
                             var_x = annee,
                             var_y = valeur,
                             debut = 1990,
                             esp_code_alternatif,
                             stade,
                             indicateur)
print(taux_evol_1990)

```




Partie expérimentale sur les GLMM : 

mon_espece <- "ANG"
mon_stade <- "ad"


library(tidyverse)
library(lme4)

ope_ang_ind <- ope_indicateur_lmm %>% 
  filter(espece == mon_espece,
         stade == mon_stade,
         indicateur == "densite_surface") %>% 
  select(-obj_libelle) %>% 
  distinct() %>% 
  mutate(pop_id = as.character(pop_id)#,
       #  valeur = log10(valeur)
         ) %>% 
  filter(pop_id != "41893")

ggplot(data = ope_ang_ind,
       aes(x = valeur)) +
  geom_density()

ggplot(data = ope_ang_ind,
       aes(x = valeur)) +
  geom_density() +
  scale_x_log10()


ggplot(data = ope_ang_ind,
       aes(x = annee,
           y = valeur)) +
  geom_point() +
  geom_smooth()

ggplot(data = ope_ang_ind,
       aes(x = annee,
           y = valeur)) +
  geom_point() +
  geom_smooth() +
  scale_y_log10()

mod <- lmerTest::lmer(valeur ~ annee + (1|pop_id) + pro_libelle,
  data = ope_ang_ind)

summary(mod)
anova(mod)
plot(mod)
plot(mod, type=c("p","smooth"), col.line=1)
plot(mod,
     sqrt(abs(resid(.)))~fitted(.),
     type=c("p","smooth"), col.line=1)
lattice::qqmath(mod)
plot(mod, rstudent(.) ~ hatvalues(.))

res <- summary(mod)$coefficients %>%
  as.data.frame() %>%
  rename(p_value = `Pr(>|t|)`) %>%
  mutate(sig = case_when(
    p_value < 0.001 ~ "***",
    p_value < 0.01 ~ "**",
    p_value < 0.05 ~ "*",
    TRUE ~ ""
  ))

res

predicted <- predict(mod) %>% 
  as.data.frame() %>% 
  set_names("predicted")


ope_ang_ind <- ope_ang_ind %>% 
  bind_cols(predicted)

ggplot(data = ope_ang_ind,
       aes(x = valeur,
           y = predicted)) +
  geom_point() +
  geom_smooth(method = "lm") +
  geom_abline()


ope_ang_ind <- ope_ang_ind %>% 
  mutate(valeur = 10^valeur,
         predicted = 10^predicted)


ggplot(data = ope_ang_ind,
       aes(x = valeur,
           y = predicted)) +
  geom_point() +
  geom_smooth() +
  geom_abline(slope = 1) 

#######################################
ope_ang_ind <- ope_indicateur_lmm %>% 
  filter(espece == "ANG",
         stade == "ind",
         indicateur == "densite_surface") %>% 
  select(-obj_libelle) %>% 
  distinct() %>% 
  mutate(pop_id = as.character(pop_id))

mod1 <- glmer(log10(valeur) ~ annee + (1|pop_id) + pro_libelle,
                    family = gaussian,
                    data = ope_ang_ind)

res1 <- summary(mod1)

res1

anova(mod1)
res1$coefficients



  ###################################################

# Modèles linéaires généralisés




library(lme4)
library(popdynmodel)
library(aspe2)

load(file = "processed_data/assemblage_tab_par_ope.rda")

rdata_tables <- misc_nom_dernier_fichier(
  repertoire = "../../../projets/ASPE/raw_data/rdata",
  pattern = "^tables")
load(rdata_tables)

mei_table <- misc_nom_dernier_fichier(
  repertoire = "../../../projets/ASPE/raw_data/rdata",
  pattern = "^mei")
load(mei_table)










ope_effectif <- ope_effectif %>% 
  filter(esp_code_alternatif %in% c("ANG", "CHE", "LPP", "BRO", "LOF", "VAR", "GAR", "VAI", "PER", "SAT", "GOU", "TRF", "CHA"))

ope_effectif_glm <- ope_effectif %>%
  filter(stade =="ind") %>% 
  mef_ajouter_type_protocole() %>% 
  mef_ajouter_surf_calc() %>% 
  mef_ajouter_ope_date() %>% 
  select(ope_id,
         ope_surface_calculee,
         esp_code_alternatif,
         valeur, 
         pro_libelle,
         annee)


ope_effectif_glm <- ope_effectif_glm %>% 
  left_join(y=operation %>% 
              select(ope_id,
                     pop_id= ope_pop_id))

ope_proto <- ope_effectif_glm %>% 
  select(-esp_code_alternatif, -valeur) %>% 
  distinct()

# Création d'un dataframe avec toutes les combinaisons possibles d'années, indicateurs, stades et esp_code_alternatif
combinaisons_ope_glm <- expand.grid(esp_code_alternatif = unique(ope_effectif_glm$esp_code_alternatif),
                                    ope_id = unique(ope_effectif_glm$ope_id))

ope_glm_complet <- ope_proto %>% 
  left_join(y = combinaisons_ope_glm) %>% 
  left_join(y = ope_effectif_glm) %>% 
  mutate(valeur = ifelse(is.na(valeur), 0, valeur))


ope_glm_complet_ang <- ope_glm_complet %>%
  filter(esp_code_alternatif == "SAT") %>% 
  mutate(pop_id = as.factor(pop_id))

mod <- glmer(valeur ~
               scale(annee)  +
               scale(ope_surface_calculee) +
               (1| pop_id) +
               pro_libelle
             , 
             family = poisson(link = "log"), 
             data = ope_glm_complet_ang)

summary(mod)

predict(mod)

ranef(mod)
coef(mod)

ggplot(ope_glm_complet_ang, aes(x = annee, y = valeur, color = pop_id)) +
  geom_point() +
  geom_line(aes(y = fitted(mod)))







##### Evaluation et comparaison des modèles
## Distribution des résidus 

chi2 <- sum(residuals(mod, type = "pearson")^2)
chi2

1-pchisq(chi2, df = df.residual(mod))


chi2 / df.residual(mod)



library(DHARMa)
resid_sim <- simulateResiduals(mod)
plot(resid_sim)



re <- ranef(mod)$pop_id

qqnorm(re$`(Intercept)`)
qqline(re$`(Intercept)`)



library(jtools)
library(effects)
summ(mod, exp = T)

ope_glm_complet_ang <- ope_glm_complet_ang %>% 
  cbind(residus = residuals(mod)) %>% 
  cbind(valeur_predite = predict(mod))

ggplot(data = ope_glm_complet_ang,
       aes(x = residus)) +
  # geom_histogram() +
  geom_density() +
  geom_vline(xintercept = mean(ope_glm_complet_ang$residus),
             col = "red",
             linetype = "dotted")


ggplot(data = ope_glm_complet_ang,
       aes(x = valeur,
           y = exp(valeur_predite))) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "lm") +
  abline(col = "red", a = 1, b = 0)



plot(allEffects(mod))



anova(mod)
plot(mod)

plot(mod, type=c("p","smooth"), col.line=1)
plot(mod,
     sqrt(abs(resid(.)))~fitted(.),
     type=c("p","smooth"), col.line=1)
lattice::qqmath(mod)
plot(mod, rstudent(.) ~ hatvalues(.))

res <- summary(mod)$coefficients %>%
  as.data.frame() %>%
  rename(p_value = `Pr(>|t|)`) %>%
  mutate(sig = case_when(
    p_value < 0.001 ~ "***",
    p_value < 0.01 ~ "**",
    p_value < 0.05 ~ "*",
    TRUE ~ ""
  ))

res

predicted <- predict(mod) %>% 
  as.data.frame() %>% 
  set_names("predicted")


mod <- mod %>% 
  bind_cols(predicted)

ggplot(data = ope_ang_ind,
       aes(x = valeur,
           y = predicted)) +
  geom_point() +
  geom_smooth(method = "lm") +
  geom_abline()


ope_ang_ind <- ope_ang_ind %>% 
  mutate(valeur = 10^valeur,
         predicted = 10^predicted)


ggplot(data = ope_ang_ind,
       aes(x = valeur,
           y = predicted)) +
  geom_point() +
  geom_smooth() +
  geom_abline(slope = 1) 


