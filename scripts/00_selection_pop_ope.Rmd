---
title: "Liste Rouge Régionale des poissons d'eau douce de Bretagne"
subtitle: "Sélection des sites et des opérations"
author: "OFB Bretagne"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
```

# Objectif : Dynamique de population des poissons d'eau douce de Bretagne - 00-Selection_pop_ope

L'objectif de cette étude est d'évaluer les tendances temporelles des poissons d'eau douce de Bretagne. Ce travail vient en appui de la révision de la liste rouge régionale. Il s'agit de produire un tableau de bord combinant divers indicateurs de la dynamique des populations des poissons d'eau douce de Bretagne. 


Dans un premier temps, ce script a pour objectif de constituer un premier dataframe rassemblant les données de la base ASPE correspondant à une zone géographique identifiée. Il s'agit de constituer un jeu de données regroupant des réseaux, des sites ainsi que des opérations de pêches ciblés qui constiturons la base de nos données pour l'étude des séries temporelles qui suivra. 


# Installation 

## Chargement des packages, fonctions et des données

```{r Chargement des packages, données et fonctions}
# Chargement des packages ----
library(aspe)
library(tidyverse)
library(mapview)
library(COGiter)
library(sf)
library(wesanderson)

# Chargement des fonctions ----
source(file = "../R/borner_series.R")

# Chargement des données ----
rdata_tables <- misc_nom_dernier_fichier(
  repertoire = "../../../../projets/ASPE/raw_data/rdata",
  pattern = "^tables")
load(rdata_tables)

# Chargement de la palette de couleur ---- 
pal <- wes_palette("AsteroidCity1")
pal2 <- wes_palette("FantasticFox1")
pal3 <- c("#007844", "#92D050", "#0087C1", "#A97B30","#FCEE21", "#00AEEF", "#1D1D1B", "#B9D9EB")

```

## Paramètres

Plusieurs paramètres sont fixés au début de chacun des scripts relatifs à l'étude. Ces paramètres sont modifiables selon les préférences et les objectifs visés. Parmi ces paramètres : 

- La taille du *buffer* (en mètres) : il s'agit de la taille du buffer lié aux opérations de pêches. 

- Les réseaux de pêches : Il s'agit des types de réseaux sélectionnés. Parmi eux se trouvent le RCS - Réseau de Contrôle de Surveillance ; le RRP - Réseaux de Référence Pérenne ; le RHP - Réseau Hydrobiologique Piscicole ; le RCA - Réseau de contrôle additionnel ; le RCO – Réseau Contrôle opérationnel. Dans notre étude, seul les trois premiers réseaux seront utilisés. Ces réseaux seront tester ensemble puis individuellement afin d'écarter un risque de biais d'objectifs. En effet, les réseaux n'ayant pas les mêmes "objectifs d'observations", un biais peut apparaïtre (ex. le réseaux RPP est un réseau "témoin", qui ne doit pas subir d'influences extérieures, il doit seulement informer des potentiels effets provoqué par le changement climatique). 

- Les types de pêches : Il existe de nombreux types de pêches : pêche partielle par point, pêche par ambiance, pêche partielle sur berge, pêche complète à un ou plusieurs passages. Ce paramètre permet de sélectionner les types de pêches souhaitées dans l'étude. 

- Le nombre minimum d'années sur les séries de pêches : il s'agit de la période minimum souhaitée. 

- Le nombre d'années manquantes consécutives maximum sur les séries de pêches : il s'agit de la période d'années manquantes consécutives maximum souhaitée dans l'analyse. 


```{r Mise en place des paramètres}
## La taille du buffer (en mètres) ----
taille_buffer <- 1000

## Les réseaux de pêches ----
mes_reseaux <- c("RCS – Réseau de Contrôle de Surveillance",
                 "RRP – Réseau de Référence Pérenne",
                 "RHP – Réseau Hydrobiologique Piscicole")

## Les types de pêches ----
mes_types_de_peche <- c("Pêche complète à un ou plusieurs passages",
                   "Pêche partielle par points (grand milieu)",
                   "Pêche par ambiances",
                   "Pêche partielle sur berge")

## Le nombre minimum d'années sur les séries de pêches  ----
n_mini_annee <- 9 

## Le nombre d'années manquantes maximum sur cette série de pêches dans les données ----
n_max_manquant <- 2

```


# Constitution du jeu de données 

## Sélection de l'aire géographique

```{r Création passerelle}
## Création d'une passerelle ----
passerelle <- mef_creer_passerelle()
```


```{r Sélection aire géographique}
## Sélection de l'aire géographique : choix des départements ----
# Exemple : La Bretagne (22, 29, 35, 56)
mes_depts <- departements_metro_geo %>% 
  filter (DEP %in% c("22", "29", "35", "56"))
```


```{r Visualisation Carte depts, eval = FALSE}
# Visualisation de la zone géographique sélectionnée ----
mes_depts %>%
  mapview::mapview()
```


## Mise en place d'un buffer

Notre étude se concentre dans cette exemple sur la Bretagne. Toutes les stations bretonnes sont alors retenues dans le jeu de données. Ici, il ne s’agit pas de réfléchir à l’échelle des bassins versants, leur limite n’étant pas toujours évidente. Cependant, un buffer est mis en place aux alentours des limites départementales afin de considérer les stations aux emplacements ambiguës et englober les stations frontalières aux limites départementales. La limite du buffer est donc à considérer en fonction de l'aire géographique considérée (cf I.B Paramètres). 

```{r Mise en place buffer}
## Mise en place d'un buffer ----
bzh_buff <- st_buffer(mes_depts, 
                      taille_buffer) # (I.B Paramètres)

# Visualisation de l'aire géographique et du buffer ----
mapview(
  list(bzh_buff, mes_depts),
  layer.name = c("Bretagne avec un buffer de 1 km", "Bretagne"),
  col.regions = list("#0A9F9D", "#FDE725FF")
)
```


```{r Visualisation point prélèvements}
# Visualisation des points de prélèvements présents dans l'aire géographique sélectionnée
pop_bzh <- point_prelevement %>%
  sf::st_as_sf(coords = c("pop_coordonnees_x", 
                          "pop_coordonnees_y"),
               crs = 2154) %>% 
  aspe::geo_attribuer(bzh_buff) %>% 
  filter(!is.na(DEP))
```





```{r, fig.height = 10, fig.width = 15}

# Dessiner la carte
ggplot(regions_metro_geo) +
  geom_sf(data = mes_depts) +
  geom_sf(data = bzh_buff) +
  geom_sf(data = pop_bzh, aes(color = DEP), size = 2) +
  scale_color_manual(values = pal3) +
  theme_bw() +
  # Ajouter une légende pour la variable DEP
  labs(color = "Département")
```





```{r Visualisation point prélèvements 2}
# Plot des points avec ggplot2
ggplot() +
  geom_sf(data = mes_depts) +
  geom_sf(data = bzh_buff) +
  geom_sf(data = pop_bzh, aes(color = DEP), size = 1) +
  scale_color_manual(values = pal3) +
  theme_minimal()
```


```{r Visualisation point prélèvements 3}
mapview(
  list(bzh_buff, mes_depts),
  layer.name = c("Bretagne avec un buffer de 1 km", "Bretagne"),
  col.regions = list("#0A9F9D", "#FDE725FF")
) + mapview (pop_bzh, shape = 20, color = "darkred", lwd =1)

```


## Sélection des réseaux et types de pêches

Après visualisation de l'aire géographique et de ses stations associées, une sauvegarde des points de prélèvements peut s'effectuer dans la passerelle. Une sélection des réseaux et des types de pêches souhaitées est également réalisée. 

Rappel : Dans le choix des données, il est nécessaire de sélectionner les réseaux de pêches souhaités. Il existe notamment 3 grands types de réseaux différents (RRP / RCS et RHP). Il est nécessaire d’être prudent lorsque ces 3 réseaux sont traités ensembles.
En effet, ces 3 réseaux n’ont pas les mêmes objectifs : les RCS et RHP mesurent les impacts anthropiques (elles sont soumises aux perturbations anthropiques). Le réseau RRP est un « témoin » susceptible d'évaluer les tendances engendrées par le changement climatique. Ces différents réseaux présentent des particularités pouvant biaiser les résultats des tendances générales. 


```{r Sauvegarde pop_id}
# Sauvegarde des points de prélèvements sélectionnés dans la passerelle ----
passerelle <- passerelle %>%
  filter(pop_id %in% pop_bzh$pop_id)
```


```{r Sélection réseaux de pêches} 
## Sélection des réseaux de pêches ---- 
passerelle <- passerelle %>%
  mef_ajouter_objectif() %>% 
  filter(obj_libelle %in% mes_reseaux)   #(I.B Paramètres)
```


```{r Sélection types de pêches}
## Création d'un dataframe "mes_ope" et sélection des types de pêches ---- 
mes_ope <- passerelle %>% 
  mef_ajouter_type_protocole() %>%
  filter(pro_libelle %in% mes_types_de_peche) %>%  #(I.B Paramètres)
  select(sta_id:ope_id, pro_libelle) %>% 
  distinct()
```


```{r Sélection nombre de pêches}
## Sélection d'une seule pêche par années, par station ----
# (pour le cas des sites avec plusieurs pêches la même année, on sélectionne par défaut
# la pêche la plus tardive)
mes_ope <- mes_ope %>%
  mef_ajouter_ope_date() %>% 
  group_by(pop_id, annee) %>% 
  filter(ope_date == max(ope_date))

```


## Sélection des caractéristiques des séries temporelles

Après avoir sélectionné les réseaux et les types de pêches, nous souhaitons sélectionner les sites qui ont été suivis pendant suffisament longtemps (afin de constituer des séries temporelles les plus grandes possibles). Il s’agit tout d’abord d’identifier le nombre d’années de données disponibles par station : --> Création d’un code : « bilan_annee_de_donnees ».

Afin d’obtenir une robustesse statistique suffisante, une sauvegarde des stations avec au moins 10 années de données sur un même point de prélèvement est appliquée. Une sélection est ensuite réalisée au niveau des séries de pêches avec au moins 9 années de données sans que les opérations successives soient éloignées de plus de 2 ans. 


```{r Création séries temporelles 1}
## Sélection des séries de pêches avec au moins 9 années de données (paramètres) ----
pop_serie_1 <- mes_ope %>%
  group_by (pop_id) %>%
  summarise(
    nombre_annees_totales = n_distinct(annee),
    premier_annee = min(annee),
    dernier_annee = max(annee),
    duree = dernier_annee - premier_annee
  )

mes_pop_id <- pop_serie_1 %>%
  filter(nombre_annees_totales > n_mini_annee) %>%  #(I.B Paramètres)
  pull(pop_id)
```


```{r Création séries temporelles 2}
## Sélection des stations ayant 2 années maximum de suivis consécutifs manquants par station ----
pop_serie_2 <- mes_ope %>%
  borner_series(var_id_site = pop_id,     #Utilisation de la fonction "borner_serie"
                var_temp = annee,
                max_nb_obs_manquantes = n_max_manquant) # (I.B Paramètres)

pop_serie_2 <- pop_serie_2 %>%
  filter(n_opes > n_mini_annee) %>% # PARAMETRE
  select(-annee_mini)

```


## Représentation graphique finale des séries temporelles sélectionnées et des types de pêches associées aux stations

```{r Représentation séries temporelles, fig.height = 10, fig.width = 15}
## Représentation graphique des stations sélectionnées et des types de pêches associées ----

mes_ope %>% 
  filter(pop_id %in% mes_pop_id) %>% 
  mef_ajouter_libelle_site() %>% 
  ggplot(aes(x = as.character(pop_libelle),
             y = annee, 
             fill= pro_libelle),
         legend.background = element_rect(fill="#ffffff")) + 
  scale_fill_manual(values= pal) +
  geom_tile() +
  labs(title = "Les stations sélectionnées et les types de pêches associées",
       subtitle = "Région Bretagne", 
       x ="",
       y = "Années",
       fill = "Type de pêche") + 
  theme_light(base_size = 11) +
  theme(panel.grid.major = element_line(color="#ffffff", size = 0.1),
        panel.grid.minor = element_line(color = "#ffffff"),
        panel.background = element_rect(fill="#faf0e6"),
        legend.position = "bottom") +
  coord_flip()

```


## Construction du dataframe de sélection des opérations finales 


```{r Sélection operations finales}
## Construction d'un nouveau dataframe avec toutes les opérations de pêches
# présentes dans les stations retenues

ope_selection <- mes_ope %>% 
  left_join(pop_serie_2) %>% 
  filter(!is.na(debut),
         annee >= debut,
         annee <= fin) %>% 
  select(-debut, -fin, -n_opes) %>% 
  ungroup()
```



## Sélection des opérations finales : Visualisation des efforts de pêches par station  

On souhaite observer les efforts de pêches effectués sur chacune des stations. 

```{r Sélection operations finales visualisation}
ope_selection_sta <- ope_selection %>%
  group_by(sta_id) %>% 
  mutate(nombre_ope_sta = n_distinct(ope_id)) 


# Afficher le tableau résumant le nombre d'"ope_id" par station
  
  # flextable::flextable() %>% 
  # flextable::autofit() %>% 
  # flextable::colformat_int(j = c(1, 2), big.mark = " ")
  # ggplot(aes(x = as.factor(sta_id), 
  #            y = nombre_ope_sta)) +
  # geom_bar(stat = "identity") + 
  # coord_flip()
```

## Visualisation des efforts de pêche par station dans l'aire géographique sélectionnée

```{r Préparation visualisation efforts pêche}
ope_selection_sta <- ope_selection_sta %>%
  select(sta_id, ope_id, pop_id, nombre_ope_sta) %>%
  left_join(point_prelevement) %>% 
  sf::st_as_sf(coords = c("pop_coordonnees_x", 
                           "pop_coordonnees_y"),
                crs = 2154) %>% 
  aspe::geo_attribuer(bzh_buff)
```


```{r Visualisation efforts pêche}
# Pour la visualisation graphique je n'ai besoin que d'un seul exemple d'ope_id par station
ope_selection_sta_n <- ope_selection_sta %>% 
  group_by(sta_id) %>% 
  sample_n(1) %>% 
  ungroup()


mapview(list(bzh_buff, mes_depts),
        layer.name = c("Bretagne avec un buffer de 1 km", "Bretagne"),
        col.regions = list("#440154FF", "#FDE725FF")) + 
  mapview(ope_selection_sta_n,
          layer.name = "Nombre operation par station", 
          size_var = "nombre_ope_sta",
          cex = "sta_id",
          lwd = 0.2,
          col.regions = "#D693E0",
          alpha = 0.8,
          legend = TRUE,
          labels = list(text = ope_selection_sta_n$nombre_ope_sta, cex = 1.5))
          
```


```{r Enregistrement passerelle}
# --- Enregistrement des opérations de pêches retenues dans la passerelle
passerelle <- passerelle %>% 
  filter(ope_id %in% ope_selection$ope_id)

```



# Vérification du jeu de données 

Il s'agit ici de détecter des erreurs potentielles dans le jeu de données constitué. 

## Les points de prélèvements et les stations

Pour chacune des pêches réalisées, des points de prélèvement attachés à des stations sont inscrits dans la base. Il s'agit ici d'identifier pour chaque station combien de point de prélèvement sont associés. Le résultat permet une vérification des doublons. 

Remarque : l’idée étant d’obtenir les séries chronologiques les plus longues, il est important de vérifier si une fusion de point de prélèvement est envisageable (en cas de proximité géographique). 

Il s'agit également d'identifier pour chaque point de prélèvement combien de station sont combinées (le résultat devant être égale à 1, sinon une erreur est probable).


```{r Recherche erreur 1}
### Recherche erreur : 1 point de prélèvement = 1 seule station ----

pop_plusieurs_sta <- mes_ope %>% 
  mef_ajouter_libelle_site(origine_libelle = "station_sandre") %>% 
  rename(sta_libelle = sta_libelle_sandre) %>%  
  mef_ajouter_libelle_site(origine_libelle = "auto") %>% 
  select(-pro_libelle, -ope_id) %>% 
  distinct()

pop_plusieurs_sta <- pop_plusieurs_sta %>% 
  group_by(pop_id) %>% 
  summarise(n_sta = n_distinct(sta_id)) %>% 
  filter(n_sta>1, !is.na(pop_id)) %>% 
  pull(pop_id) %>% 
  length()
```

Nombre de points (`pop_id`) correspondant à plusieurs stations (`sta_id`) : `r pop_plusieurs_sta`

```{r Recherche erreur 2}
### Recherche erreur : 1 station = ? opération(s) (vérification doublons) ----
sta_plusieurs_pop <- mes_ope %>% 
  mef_ajouter_libelle_site(origine_libelle = "station_sandre") %>% 
  rename(sta_libelle = sta_libelle_sandre) %>%  
  mef_ajouter_libelle_site(origine_libelle = "auto") %>% 
  select(-pro_libelle, -ope_id) %>% 
  distinct()

sta_plusieurs_pop_1 <- sta_plusieurs_pop %>% 
  group_by(sta_id) %>% 
  summarise(n_pop = n_distinct(pop_id)) %>% 
  filter(n_pop>1, !is.na(sta_id)) %>% 
  pull(sta_id) %>% 
  unique()

sta_plusieurs_pop <- sta_plusieurs_pop %>% 
  ungroup() %>% 
  filter(sta_id %in% sta_plusieurs_pop_1) %>% 
  dplyr::select (sta_id, sta_libelle, pop_id, pop_libelle) %>% 
  dplyr::distinct() %>% 
  arrange(sta_libelle)

sta_plusieurs_pop %>% 
  flextable::flextable() %>% 
  flextable::autofit() %>% 
  flextable::colformat_int(j = c(1, 3), big.mark = " ")
```



# Sauvegarde : 

```{r Sauvegarde}
# SAUVEGARDE ----
save(pop_serie_2,
     ope_selection,
     passerelle,
     file = "../processed_data/selection_pop_ope.rda")
```

# Pour exporter mes objets vers QGIS : 

```{r}
#st_write(mes_depts, "../../liste_rouge_regionale/QGIS/mes_depts.shp")
#st_write(pop_bzh, "../../liste_rouge_regionale/QGIS/pop_bzh.shp")
#st_write(bzh_buff, "../../liste_rouge_regionale/QGIS/bzh_buff.shp")
```

